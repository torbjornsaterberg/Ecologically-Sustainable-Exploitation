#------------------------------------------------------------#
#------------------------------------------------------------#
#                                                            #
#         Ecologically Sustainable Exploitation Rates        #
#    - A multispecies approach for fisheries management -    #
#                                                            #
#                   Figures and tables                       #
#------------------------------------------------------------#
#------------------------------------------------------------#
# 
# Säterberg et al.(2019)  
# 
# Code written by: Torbjörn Säterberg (torbjorn.saterberg@slu.se) 

#------------------------------------------------------------#
#                         Figure 1                           #
# A schematic figure illustrating tresholds for ecologically #
# sustainable exploitation rates.                            #
#------------------------------------------------------------#
# Requires: param - MAR-model parameters and data 
#           Criteria - a list containing risks and critical biomass limits
#           ESER - a function for estimating ESER-limits

Figure1 <- function(param,Criteria){
  
  mean_survey <- param$mean_ln
  
  # Calculate ecological sustainable fishing mortalities
  EPS <- ESER(param,Criteria)
  S <- length(param$A) # number of species in the community
  
  
  if(sum(EPS!="NA",na.rm=T)>1){
    
    
    # mean and covariance of stationary distribution with unchanged fishing mortality
    mu <- solve(diag(S)-param$B)%*%(param$A+param$C%*%param$U_mean+param$D%*%(param$F_mean)) # Mean value with mean fishing mortalities
    mu <- mu+mean_survey
    V_temp <- solve(diag(S^2)-param$B%x%param$B)%*%as.matrix(as.vector(param$R+param$C%*%param$U_cov%*%t(param$C))) # Calculate the(add this if covariates affect stationary distribution: param$C%*%param$U_cov%*%t(param$C)) Vec-form of the variance-covariance matrix
    V <- matrix(V_temp,S,S,byrow=FALSE) # Re-order to a Variance-covariance matrix
    
    # Calculate mean for changed fishing mortalities
    F_mean.low <- param$F_mean
    F_mean.low[Criteria$spID] <- EPS[1]
    F_mean.high <- param$F_mean
    F_mean.high[Criteria$spID] <- EPS[2]
    mu.F_low <- solve(diag(S)-param$B)%*%(param$A+param$C%*%param$U_mean+param$D%*%(F_mean.low)) # Mean value with mean fishing mortalities  
    mu.F_low <- mu.F_low + mean_survey
    mu.F_high <- solve(diag(S)-param$B)%*%(param$A+param$C%*%param$U_mean+param$D%*%(F_mean.high)) # Mean value with mean fishing mortalities  
    mu.F_high <- mu.F_high + mean_survey
    thresh <- Criteria$threshold + mean_survey # threshold should be rescale to ordinary scale
    
    
    # Calculate values for objective function
    F_ESER <- c((EPS[1]-(EPS[2]-EPS[1])/10),(EPS[2]+(EPS[2]-EPS[1])/10))
    F_x <-seq(F_ESER[1],F_ESER[2],length.out=100)
    obj_x <- apply(t(F_x),2,f,Criteria,param)
    
    path <- "Output/Fig1.png"
    png(file=path,width=180,height=240,
        units="mm",res=300,pointsize=12)
    
    # make a design using layout
    mat <- c(2,3,4,1)
    width <- c(1,1,1,1)
    height <- c(1,1,1,1)
    A <- layout(mat,widths=width,heights=height)
    
    # plot objective function
    par(mar=c(3,3,1,1))
    par(mgp=c(2,1,0))
    par(cex=1)
    plot(-obj_x~F_x,type="l",ylab="Multispecies objective",
         xlab="Sprat exploitation rate",cex.axis=10/12,yaxt='n',ylim=c(-0.09,0.16))
    axis(2,c(-0.1,-0.05,0,0.05,0.1,0.15),labels=c(-0.1,"",0.0,"",0.1,""),cex.axis=10/12)
    y_pos <- c(par('usr')[3],par('usr')[3]+0.8*(par('usr')[4]-par('usr')[3]))
    lines(x=c(EPS[1],EPS[1]),y=y_pos,lty=2)
    text(x=c(EPS[1]),y=y_pos[2],"Low",cex=10/12,font=1,pos=3)
    lines(x=c(EPS[2],EPS[2]),y=y_pos,lty=2)
    text(x=c(EPS[2]),y=y_pos[2],"High",cex=10/12,font=1,pos=3)
    lines(x=c(0,0),y=y_pos,lty=2)
    text(x=c(0),y=y_pos[2],"Mean historical",cex=10/12,font=1,pos=3)
    x_pos=par('usr')[1]+0.03*(par('usr')[2]-par('usr')[1])
    y_pos=par('usr')[3]+(1-0.04)*(par('usr')[4]-par('usr')[3])
    text(x_pos,y_pos,"d",adj=0.5,pos=1,cex=1,font=2)
    
    # plot transparent region showing where objective is not met.
    cord <- par('usr')
    color <- "gray"
    color <- adjustcolor(color,alpha.f=0.5)
    rect(cord[1],cord[3],cord[2],0,col=color,border=NA)
    
    # make three stationary plots(mu, mu_Fhigh, mu_Flow)
    par(mar=c(3,2,0,0))
    par(usr=c(3.5,8.5,0,2.5))
    colored=c("black","red","blue")
    
    # F_low
    stat_dist(mu.F_low,V,S,thresh)
    p=0.05
    x_pos=par('usr')[1]+p*(par('usr')[2]-par('usr')[1])
    y_pos=par('usr')[3]+(1-p)*(par('usr')[4]-par('usr')[3])
    text(x_pos,y_pos,"a",adj=0.5,pos=1,cex=1,font=2)
    mtext("Ln(Biomass)",1,line=2)
    mtext("Low",2,line=-0.5,font=1,cex=10/12)
    legend(x=7.97,y=par('usr')[4]-0.05,col=colored,fill=colored,
           cex=10/12,legend=c("Cod","Sprat","Herring"))
    
    # F_mean historical
    stat_dist(mu,V,S,thresh)
    x_pos=par('usr')[1]+p*(par('usr')[2]-par('usr')[1])
    y_pos=par('usr')[3]+(1-p)*(par('usr')[4]-par('usr')[3])
    text(x_pos,y_pos,"b",adj=0.5,pos=1,cex=1,font=2)
    mtext("Ln(Biomass)",1,line=2)
    mtext("Sprat exploitation rate",2,line=0.75,font=1)
    mtext("Mean historical",2,line=-0.5,font=1,cex=10/12)
    
    # F_high
    stat_dist(mu.F_high,V,S,thresh)
    x_pos=par('usr')[1]+p*(par('usr')[2]-par('usr')[1])
    y_pos=par('usr')[3]+(1-p)*(par('usr')[4]-par('usr')[3])
    text(x_pos,y_pos,"c",adj=0.5,pos=1,cex=1,font=2)
    mtext("Ln(Biomass)",1,line=2) #,cex=2/3
    mtext("High",2,line=-0.5,font=1,cex=10/12)
    
    
    dev.off() # end of plot to pdf
  }
  
}

# Sub-function for plotting the stationary distribution of a MAR(1)-model
stat_dist <- function(mu,V,S,thresh){ 
  
  par(cex=1)
  colored <- c("black","red","blue")
  x <- seq(4, 8, length=100)
  hx <- dnorm(x,mean=mu[1],sd=sqrt(V[1,1]))
  
  plot(x, hx, type="n", xlab="",ylab="", 
       main="",axes=FALSE,xlim=c(3.5,8.5),ylim=c(0,2.5))
  
  for(i in 1:S){
    
    x <- seq((mu[i]-1),mu[i]+1, length=100)
    hx <- dnorm(x,mean=mu[i],sd=sqrt(V[i,i]))
    hx_thresh <- dnorm(thresh[i],mean=mu[i],sd=sqrt(V[i,i]))
    
    j <-  x <= thresh[i]
    lines(x, hx,col=colored[i],lwd=2)
    if(any(j)){
      polygon(c(x[j],thresh[i],thresh[i]), c(hx[j],hx_thresh,0),col=colored[i],border=NA)
      
    }
    #abline(v=thresh[i],lty=2,col=i)
    x_pos <- c(thresh[i],thresh[i])
    y_pos <- c(0,par('usr')[4]/(4/3))
    lines(x=x_pos,y=y_pos,lty=2,col=colored[i],lwd=1)
    text(x_pos[1],y_pos[2],"Blim",col=colored[i],pos=2,cex=10/12)
    
    axis(1, at=seq(3.5,8.5,length.out=11), pos=0, cex.axis=10/12) 
    
    
  }
}

#----------------------------------#
#               Fig 2              #
#     -Time series projections  -  #
#----------------------------------# 
Figure2 <- function(param){

#--------------------------------------------------------------------#
#                       Compute condition R^2                        #
# - the proportion of var in Xt that is explained by Xt-1, Ut & Kt - #
#--------------------------------------------------------------------#  

deltaX <- param$X[1:(dim(param$X)[1]-1),]-param$X[2:dim(param$X)[1],]
deltaX_hat <- apply(deltaX,2,mean)
deltaX_hat <- matrix(deltaX_hat,dim(deltaX)[1],dim(deltaX)[2],byrow=TRUE)
Stot <- (deltaX-deltaX_hat)^2
SStot <- apply(Stot,2,sum)

Pred <- param$B%*%t(param$X[1:(dim(param$X)[1]-1),])+
  param$C%*%t(param$U[2:(dim(param$X)[1]),])+param$D%*%t(param$F[2:(dim(param$X)[1]),]) # Model prediction
deltaPred <- t(param$X[1:(dim(param$X)[1]-1),])-Pred # Predicted change in abundance

Sres <- (deltaX-t(deltaPred))^2 
SSres <- apply(Sres,2,sum)

Cond_R2 <- 1-SSres/SStot # Conditional R2


#---------------------------------------------#
# Calculate bootstrapped confidence intervals #
#---------------------------------------------#

# mean predictions
Y_pred <- matrix(0,dim(param$X)[2],dim(param$X)[1])
Y_pred[,1] <- t(param$X[1,])
for(i in c(2:(dim(param$X)[1]))){
  Y_pred[,i] <- param$A+param$B%*%Y_pred[,i-1]+param$C%*%param$U[i,]+param$D%*%param$F[i,]
}

# Set up for calculating conf intervals around predictions
Y_temp <- matrix(0,dim(param$X)[2],dim(param$X)[1])
Y_temp[,1] <- t(param$X[1,])
Y_rand <- c()
repl <- 2000 # nb of replicates for conf int calculation
Res <- param$Res #residuals

# Create matrix for resampling residuals
Q<-c()
for(i in 1:repl){ Q <- rbind(Q,sample(c(1:dim(Res)[1]),dim(Res)[1],replace=FALSE))} 

# Random predictions
for(j in 1:repl){
  Res_boot <- Res[Q[j,],] 
  
  for(i in c(2:(dim(param$X)[1]))){
    Y_temp[,i] <- param$A+param$B%*%Y_temp[,i-1]+param$C%*%param$U[i,]+param$D%*%param$F[i,]+Res_boot[i-1,]
  }
  Y_rand <- cbind(Y_temp,Y_rand)
}

# Extract confidence intervals
se <- c()
for(i in 1:(dim(Y_temp)[1]*dim(Y_temp)[2])){
  index <- seq.int(i,dim(Y_rand)[1]*dim(Y_rand)[2],dim(Y_temp)[1]*dim(Y_temp)[2])
  se[i] <- sd(Y_rand[index])
}
se <- matrix(se,dim(Y_pred)[1],dim(Y_pred)[2])
Konf <- se*1.96


#-------------#
# Plot figure #
#-------------#

path <- "Output/Fig2.pdf"
pdf(file=path,width=(8/2.54),height=(12/2.54))#,units="in",res=300)
par(mar=c(2,3,1,1))
par(mgp=c(2,1,0))
par(mfcol=c(3,2))
par(oma=c(1,0,0,0))

p=0.1
r=0.27
q=0.1
Years <- c(1988:2014)

off_set <- param$mean_ln

plot((Y_pred[1,]+off_set[1])~Years,type="l",ylim=c(3,6),xlab="Year",ylab="Ln(Cod biomass)",cex.axis=10/12)
points((Y_pred[1,]+Konf[1,]+off_set[1])~Years,type="l",lty=2)
points((Y_pred[1,]-Konf[1,]+off_set[1])~Years,type="l",lty=2)
points((param$X[,1]+off_set[1])~Years,type="p")
x_pos=par('usr')[1]+p*(par('usr')[2]-par('usr')[1])
y_pos=par('usr')[3]+(1-p)*(par('usr')[4]-par('usr')[3])
text(x_pos,y_pos,expression(bold(a)),adj=0.5,cex=1)
x_pos=par('usr')[1]+r*(par('usr')[2]-par('usr')[1])
y_pos=par('usr')[3]+q*(par('usr')[4]-par('usr')[3])
text(x_pos,y_pos,bquote(R^2==.(round(Cond_R2[1],digits=2))),adj=0.5,cex=10/12,col="red")

plot((Y_pred[2,]+off_set[2])~Years,type="l",ylim=c(5.5,8.5),xlab="Year",ylab="Ln(Sprat biomass)",cex.axis=10/12)
points((Y_pred[2,]+Konf[2,]+off_set[2])~Years,type="l",lty=2)
points((Y_pred[2,]-Konf[2,]+off_set[2])~Years,type="l",lty=2)
points((param$X[,2]+off_set[2])~Years,type="p")
x_pos=par('usr')[1]+p*(par('usr')[2]-par('usr')[1])
y_pos=par('usr')[3]+(1-p)*(par('usr')[4]-par('usr')[3])
text(x_pos,y_pos,expression(bold(b)),adj=0.5,cex=1)
x_pos=par('usr')[1]+r*(par('usr')[2]-par('usr')[1])
y_pos=par('usr')[3]+q*(par('usr')[4]-par('usr')[3])
text(x_pos,y_pos,bquote(R^2==.(round(Cond_R2[2],digits=2))),adj=0.5,cex=10/12,col="red")

plot((Y_pred[3,]+off_set[3])~Years,type="l",ylim=c(5.5,8.5),xlab="Year",ylab="Ln(Herring biomass)",cex.axis=10/12)
points((Y_pred[3,]+Konf[3,]+off_set[3])~Years,type="l",lty=2)
points((Y_pred[3,]-Konf[3,]+off_set[3])~Years,type="l",lty=2)
points((param$X[,3]+off_set[3])~Years,type="p")
x_pos=par('usr')[1]+p*(par('usr')[2]-par('usr')[1])
y_pos=par('usr')[3]+(1-p)*(par('usr')[4]-par('usr')[3])
text(x_pos,y_pos,expression(bold(c)),adj=0.5,cex=1)
x_pos=par('usr')[1]+r*(par('usr')[2]-par('usr')[1])
y_pos=par('usr')[3]+q*(par('usr')[4]-par('usr')[3])
text(x_pos,y_pos,bquote(R^2==.(round(Cond_R2[3],digits=2))),adj=0.5,cex=10/12,col="red")
mtext("Year",1,2,cex=10/12)

plot(param$F[,1]~Years,type="l",xlab="Year",ylab="Cod exploitation rate",ylim=c(-3,3.5),cex.axis=10/12)
points(param$F[,1]~Years)
x_pos=par('usr')[1]+p*(par('usr')[2]-par('usr')[1])
y_pos=par('usr')[3]+(1-p)*(par('usr')[4]-par('usr')[3])
text(x_pos,y_pos,expression(bold(d)),adj=0.5,cex=1)
plot(param$F[,2]~Years,type="l",xlab="Year",ylab="Sprat exploitation rate",ylim=c(-3,3),cex.axis=10/12)
points(param$F[,2]~Years)
x_pos=par('usr')[1]+p*(par('usr')[2]-par('usr')[1])
y_pos=par('usr')[3]+(1-p)*(par('usr')[4]-par('usr')[3])
text(x_pos,y_pos,expression(bold(e)),adj=0.5,cex=1)
plot(param$F[,3]~Years,type="l",xlab="Year",ylab="Herring exploitation rate",ylim=c(-3,3),cex.axis=10/12)
points(param$F[,3]~Years)
x_pos=par('usr')[1]+p*(par('usr')[2]-par('usr')[1])
y_pos=par('usr')[3]+(1-p)*(par('usr')[4]-par('usr')[3])
text(x_pos,y_pos,expression(bold(f)),adj=0.5,cex=1)
mtext("Year",1,2,cex=10/12)

dev.off()
}

#----------------------------------------------------------#
#                       Figure 3                           #
# - Probability of Ecologically sustainable exploitation - #
#----------------------------------------------------------#
#
# requires: sub-functions filled.contour3, filled.contour &
# data created by subfunction Fig3data.

Figure3 <- function(){
  path_output <- "Output/Fig3_Final_model.tiff"
  path_data <- "Input/Fig3_data_Final model"
  tiff(file=path_output,width=180,
       height=180,units="mm",res=300)
  
  # initial settings 
  d <- 0
  par(mgp=c(2,1,0))
  par(mar=c(3,3,1,1.2))
  
  # use layout to set up plot
  mat <- matrix(1:9,3,3)
  mat <- cbind(mat,c(10,10,0))
  mat <- cbind(c(11:13),mat)
  widths <- c(0.1,rep(1,3),0.5)
  heights<- c(rep(1,3))
  A <- layout(mat,widths=widths,heights=heights)
  par(cex=1)
  
  # Set the apperance of help lines
  linecol <- "gray" # Colour for help-lines
  lineweight <- 1
  linetype <- 5
  
  # Set color palette
  colors <- colorRampPalette(c("white","yellow","red","black"))(10)
  col <- "red"
  
  F.cod=F.sprat=F.herring <- c(0.5,0,-0.5) # use those fixed fishing mortalities
  
  # This set of fishing mortalities are investigated
  value <- 30 
  F_cod <- seq(from=-1.5,to=1.5,length.out=value)
  F_sprat <- seq(from=-2.35, to=2.35, length.out=value)
  F_herring <- seq(from=-2.2,to=2.2,length.out=value)
  
  par(cex.axis=10/12)
  ########################################
  # Plot for fixed Cod fishing mortalities
  #
  
  
  for(i in 1:length(F.cod)){
    # load data
    N_data <- read.table(paste(path_data,"/Fish_mort_cod",F.cod[i],".tab",sep=""))
    plot_mat <- reshape(N_data, v.names="obj_tot",timevar="F.Sprat",idvar="F.Herring",direction="wide")
    filled.contour3(F_sprat,F_herring,t(as.matrix(plot_mat[,-1]))/500,
                    xlab="Sprat exploitation rate",ylab="Herring exploitation rate",levels=c(0:10)/10,
                    col=colors
    )       
    d <- d+1 # keep track of which letter
    
    # Write text
    pos_x <- par("usr")[1]+diff(par("usr")[1:2])/10
    pos_y <- par("usr")[4] - diff(par("usr")[3:4])/10
    text(pos_x,pos_y,letters[d],font=2,cex=1)
    if(i==1){
      mtext("COD",font=2,col=col)
    }
    
    #Draw help-lines
    abline(h=0,lty=linetype,col=linecol,lwd=lineweight)
    abline(v=0,lty=linetype,col=linecol,lwd=lineweight)
  }
  # End of fixed cod plot
  ########################
  
  ##########################################
  # Plot for fixed Sprat fishing mortalities
  #
  
  for(i in 1:length(F.sprat)){
    # load data
    N_data <- read.table(paste(path_data,"/Fish_mort_sprat",F.sprat[i],".tab",sep=""))
    plot_mat <- reshape(N_data, v.names="obj_tot",timevar="F.Cod",idvar="F.Herring",direction="wide")
    
    filled.contour3(F_cod,F_herring,t(as.matrix(plot_mat[,-1]))/500,
                    xlab="Cod exploitation rate",ylab="Herring exploitation rate",levels=c(0:10)/10,
                    col=colors)       
    
    d <- d+1 # keep track of which letter
    
    # Write text
    pos_x <- par("usr")[1]+diff(par("usr")[1:2])/10
    pos_y <- par("usr")[4] - diff(par("usr")[3:4])/10
    text(pos_x,pos_y,letters[d],font=2,cex=1)
    if(i==1){
      mtext("SPRAT",font=2,col=col)
    }
    # Draw help lines
    abline(h=0,lty=linetype,col=linecol,lwd=lineweight)
    abline(v=0,lty=linetype,col=linecol,lwd=lineweight)
  }
  # End of fixed sprat plot
  #########################
  
  ########################################
  # Plot for fixed herring fishing mortalities
  for(i in 1:length(F.herring)){
    # Load data
    N_data <- read.table(paste(path_data,"/Fish_mort_herring",F.herring[i],".tab",sep=""))
    plot_mat <- reshape(N_data, v.names="obj_tot",timevar="F.Cod",idvar="F.Sprat",direction="wide")
    filled.contour3(F_cod,F_sprat,t(as.matrix(plot_mat[,-1]))/500,
                    xlab="Cod exploitation rate",ylab="Sprat exploitation rate",levels=c(0:10)/10,
                    col=colors
    )       
    
    d <- d+1 # keep track of letters
    
    # write text
    pos_x <- par("usr")[1]+diff(par("usr")[1:2])/10
    pos_y <- par("usr")[4] - diff(par("usr")[3:4])/10
    text(pos_x,pos_y,letters[d],font=2,cex=1)
    if(i==1){
      mtext("HERRING",font=2,col=col)
    }
    #Draw help-lines
    abline(h=0,lty=linetype,col=linecol,lwd=lineweight)
    abline(v=0,lty=linetype,col=linecol,lwd=lineweight)
  }
  # End of fixed herring plot
  ###########################
  
  ##############
  # add legend
  plot.new()
  #par(mar=c(3,3,1,1))
  filled.legend(F_cod,F_sprat,t(as.matrix(plot_mat[,-1]))/500, col=colors,
                ylab="",zlim=c(0,1))
  mtext("P(Ecologically sustainable exploitation)",2,2)
  # End of legend subplot
  #######################
  
  # Plot text to the left of figure
  par(mar=c(3,0,1,0))
  plot.new()
  par(cex=1)
  pos_y <- par("usr")[3]+diff(par("usr")[3:4])/2 # plot centered beside plots
  pos_x <- par("usr")[2]
  text(pos_x,pos_y,"HIGH",srt=90,adj=c(0.5,0),font=2,col=col)
  
  plot.new()
  pos_y <- par("usr")[3]+diff(par("usr")[3:4])/2 # plot centered beside plots
  pos_x <- par("usr")[2]
  text(pos_x,pos_y,"INTERMEDIATE",srt=90,adj=c(0.5,0),font=2,col=col)
  
  plot.new()
  pos_y <- par("usr")[3]+diff(par("usr")[3:4])/2 # plot centered beside plots
  pos_x <- par("usr")[2]
  text(pos_x,pos_y,"LOW",srt=90,font=2,adj=c(0.5,0),col=col)
  
  dev.off()
}

#-----------------------------------#
# Sub-functions for plotting fig. 3 #
#-----------------------------------#

# Note!!! Producing data for fig 3 is time-consuming  
Fig3_data <- function(Boot){
  # initialize parameters
  value <- 30
  eps <- 0
  n_boot <- length(Boot)-1
  F_cod <- seq(from=-1.5,to=1.5,length.out=value)
  F_sprat <- seq(from=-2.35, to=2.35, length.out=value)
  F_herring <- seq(from=-2.2,to=2.2,length.out=value)
  
  # input for objectiv function
  F.cod=F.sprat=F.herring <- c(-0.5,0,0.5) # use those fixed fishing mortalities
  F_cod_sprat <- expand.grid(F_cod,F_sprat)
  colnames(F_cod_sprat) <- c("F.Cod","F.Sprat")
  F_cod_herring <- expand.grid(F_cod,F_herring)
  colnames(F_cod_herring) <- c("F.Cod","F.Herring")
  F_sprat_herring <- expand.grid(F_sprat,F_herring)
  colnames(F_sprat_herring) <- c("F.Sprat","F.Herring")
  
  # write out sprat and herring data for 3 values of cod fishing
  for(l in c(1:length(F.cod))){ 
    obj_tot <- rep(FALSE,dim(F_sprat_herring)[1])
    for(i in c(1:n_boot)){
      Boot_temp <- Boot[[i]]
      
      obj_f <-c()
      for(j in 1:dim(F_sprat_herring)[1]){
        # check if system is unstable
        if(any(Mod(eigen(Boot_temp$B)$values)>1)){
          obj_f[j] <- FALSE
        }else{
          Boot_temp$K_mean <- as.matrix(c(F.cod[l],unlist(F_sprat_herring[j,])))
          obj_f[j] <- f(0,Criteria,Boot_temp)<0
        }
      }
      obj_tot <- obj_tot+obj_f
      print(i)
    }
    N_data <- cbind(F_sprat_herring,obj_tot)
    path <- paste("Input/Fig3_data/Fish_mort_cod",F.cod[l],".tab",sep="")
    write.table(N_data,file=path,col.names=TRUE)
  }
  
  # write out cod and herring data for 3 values of sprat fishing
  for(l in c(1:length(F.sprat))){ 
    obj_tot <- rep(FALSE,dim(F_cod_herring)[1])
    for(i in c(1:n_boot)){
      Boot_temp <- Boot[[i]]
      
      obj_f <-c()
      for(j in 1:dim(F_cod_herring)[1]){
        # check if system is unstable
        if(any(Mod(eigen(Boot_temp$B)$values)>1)){
          obj_f[j] <- FALSE
        }else{
          Boot_temp$K_mean <- as.matrix(c(F_cod_herring[j,1],F.sprat[l],F_cod_herring[j,2]))
          obj_f[j] <- f(0,Criteria,Boot_temp)<0
        }
      }
      obj_tot <- obj_tot+obj_f
      print(i)
    }
    N_data <- cbind(F_cod_herring,obj_tot)
    
    path <- paste("Input/Fig3_data/Fish_mort_sprat",F.sprat[l],".tab",sep="")
    write.table(N_data,file=path,col.names=TRUE)
  }
  
  # write out cod and herring data for 3 values of herring fishing
  for(l in c(1:length(F.herring))){ 
    obj_tot <- rep(FALSE,dim(F_cod_sprat)[1])
    for(i in c(1:n_boot)){
      Boot_temp <- Boot[[i]]
      
      obj_f <-c()
      for(j in 1:dim(F_cod_sprat)[1]){
        # check if system is unstable
        if(any(Mod(eigen(Boot_temp$B)$values)>1)){
          obj_f[j] <- FALSE
        }else{
          Boot_temp$K_mean <- as.matrix(c(F_cod_sprat[j,1],F_cod_sprat[j,2],F.herring[l]))
          obj_f[j] <- f(0,Criteria,Boot_temp)<0
        }
      }
      obj_tot <- obj_tot+obj_f
      print(i)
    }
    N_data <- cbind(F_cod_sprat,obj_tot)
    path <- paste("Input/Fig3_data/Fish_mort_herring",F.herring[l],".tab",sep="")
    write.table(N_data,file=path,col.names=TRUE)
  }
}


# Plotting 3d surfaces
filled.contour3 <-
  function (x = seq(0, 1, length.out = nrow(z)),
            y = seq(0, 1, length.out = ncol(z)), z, xlim = range(x, finite = TRUE), 
            ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), 
            levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, 
            col = color.palette(length(levels) - 1), plot.title, plot.axes, 
            key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, 
            axes = TRUE, frame.plot = axes,mar, ...) 
  {
    
    if (missing(z)) {
      if (!missing(x)) {
        if (is.list(x)) {
          z <- x$z
          y <- x$y
          x <- x$x
        }
        else {
          z <- x
          x <- seq.int(0, 1, length.out = nrow(z))
        }
      }
      else stop("no 'z' matrix specified")
    }
    else if (is.list(x)) {
      y <- x$y
      x <- x$x
    }
    if (any(diff(x) <= 0) || any(diff(y) <= 0)) 
      stop("increasing 'x' and 'y' values expected")
    plot.new()
    plot.window(xlim, ylim, "", xaxs = xaxs, yaxs = yaxs, asp = asp)
    if (!is.matrix(z) || nrow(z) <= 1 || ncol(z) <= 1) 
      stop("no proper 'z' matrix specified")
    if (!is.double(z)) 
      storage.mode(z) <- "double"
    .filled.contour(as.double(x), as.double(y), z, as.double(levels), 
                    col = col)
    if (missing(plot.axes)) {
      if (axes) {
        title(main = "", xlab = "", ylab = "")
        Axis(x, side = 1)
        Axis(y, side = 2)
      }
    }
    else plot.axes
    if (frame.plot) 
      box()
    if (missing(plot.title)) 
      title(...)
    else plot.title
    invisible()
  }

# Plotting filled legends
filled.legend <- function (x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1, 
                          length.out = ncol(z)), z, xlim = range(x, finite = TRUE), 
            ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), 
            levels = pretty(zlim, nlevels), nlevels = 10, color.palette = cm.colors, 
            col = color.palette(length(levels) - 1), plot.title, plot.axes, 
            key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, 
            axes = TRUE, frame.plot = axes, ...) 
  {
   
     if (missing(z)) {
      if (!missing(x)) {
        if (is.list(x)) {
          z <- x$z
          y <- x$y
          x <- x$x
        }
        else {
          z <- x
          x <- seq.int(0, 1, length.out = nrow(z))
        }
      }
      else stop("no 'z' matrix specified")
    }
    else if (is.list(x)) {
      y <- x$y
      x <- x$x
    }
    if (any(diff(x) <= 0) || any(diff(y) <= 0)) 
      stop("increasing 'x' and 'y' values expected")
    
    plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", 
                yaxs = "i")
    rect(0, levels[-length(levels)], 1, levels[-1L], col = col)
    if (missing(key.axes)) {
      if (axes) 
        axis(2)
    }
    else key.axes
    box()
  }


#########################
# Supplementary figures #
#########################

#-------------------------------------------------------------#
# Fig S1 - A plot used to exemplify a stationary distribution #
#-------------------------------------------------------------#
# requires mnormt and sub-function stat_dist_test

FigureS1 <- function(param){

# Initial settings  
mean_value <- param$mean_ln
S <- length(param$A)
t <- 100
E <- rmnorm(n = t, mean = rep(0, S), param$R, sqrt=NULL)
Y <- matrix(0,3,t)
Y[,1]<- param$X[1,] # initial values

# simulate data
for(i in 2:t){
  Y[,i] <- param$B%*%Y[,i-1] + t(t(E[i,]))
}
Y + mean_value


# Plot figure
path <- "Output/S1.png"
png(file=path,width=((1.5*8.7)/2.54),height=((1.5*8.7)/2.54),
    units="in",res=300)
mat <- matrix(c(1,2),1,2)
widths <- c(2,1)
heights <- c(1,1)

layout(mat=mat,widths=widths,heights=heights)

par(mar = c(4.1, 4.1, 1.1, 0))
par(mgp=c(2,1,0))

matplot(t(Y+mean_value),pch=c(1,2,16),col=c("black","red","blue"),ylim=c(3.5,8.5),
        xlab="Time",ylab="Ln(Biomass)")
matlines(t(Y+mean_value),col=c("black","red","blue"))

mu <- solve(diag(S)-param$B)%*%(param$C%*%param$U_mean)+mean_value
V_temp <- solve(diag(S^2)-param$B%x%param$B)%*%as.matrix(as.vector(param$R)) # Calculate the(add this if covariates affect stationary distribution: param$C%*%param$U_cov%*%t(param$C)) Vec-form of the variance-covariance matrix
V <- matrix(V_temp,S,S,byrow=FALSE) # Re-order to a Variance-covariance matrix

par(mar = c(4.1, 0, 1.1, 0.5))
stat_dist_test(mu,V,S)
legend(x="topright",col=c("black","red","blue"),
       legend=c("Species 1","Species 2","Species 3"),pch=c(1,2,16))

dev.off()
}

# Plot stationary distribution of a MAR(1)-model
stat_dist_test <- function(mu,V,S){ 
  colored <- c("black","red","blue")
  x <- seq(4, 8, length=100)
  hx <- dnorm(x,mean=mu[1],sd=sqrt(V[1,1]))

  plot(hx, x, type="n", xlab="",
       ylab="", main="",axes=FALSE,col=colored[1],xlim=c(0,2.5),ylim=c(3.5,8.5))

  for(i in 1:S){
    
    x <- seq((mu[i]-1),mu[i]+1, length=100)
    hx <- dnorm(x,mean=mu[i],sd=sqrt(V[i,i]))
    
    lines(hx, x,col=colored[i],lwd=2)
    
    
  }
}

#--------------------------------------------------#
# Fig S2 - Partial correlation function and qqplot #
#--------------------------------------------------#

FigureS2 <- function(param){ 
path <- "Output/S2.png"
png(file=path,width=11.4/2.54,height=8.7/2.54,units="in",
    res=300)
par(mfcol=c(3,2))
par(mar=c(3,3,1.3,1))
par(mgp=c(2,1,0))

# normal quantile plots
qqnorm(param$Res[,1],main="")
mtext(expression(bold(a)),side=3,line=1,adj=0,padj=1)
qqline(param$Res[,1])
qqnorm(param$Res[,2],main="")
mtext(expression(bold(b)),side=3,line=1,adj=0,padj=1)
qqline(param$Res[,2])
qqnorm(param$Res[,3],main="")
mtext(expression(bold(c)),side=3,line=1,adj=0,padj=1)
qqline(param$Res[,3])

# Autcorrelation function(check if there is autcorrelation in residuals)
pacf(param$Res[,1],main="")
mtext(expression(bold(d)),side=3,line=1,adj=0,padj=1)
pacf(param$Res[,2],main="")
mtext(expression(bold(e)),side=3,line=1,adj=0,padj=1)
pacf(param$Res[,3],main="")
mtext(expression(bold(f)),side=3,line=1,adj=0,padj=1)

dev.off()
}

#-------------------------------------------------#
# Fig S3 - Check for non-linearities in residuals #
#-------------------------------------------------#
FigureS3 <- function(param){

# initial settings
S <- dim(param$X)[2]
t <- dim(param$X)[1]

path <- "Output/S3.png"
png(file=path,width=17.8/2.54,height=17.8/2.54,units="in",
    res=300)
par(mfrow=c(4,3))
par(mar=c(3,3,1.3,1))
par(mgp=c(2,1,0))

# check for unexplained non-linearities in species interactions
i_max=sum(param$B!=0)
ind <- which(param$B!=0,arr.ind=TRUE)
for(i in c(1:i_max)){
  PART_Y <- param$Res[,ind[i,1]]# OBS! use this if partial residuals -> param$B[ind[i,1],ind[i,2]]*param$X[1:(dim(param$X)[1]-1),ind[i,2]]
  X <- param$X[1:(dim(param$X)[1]-1),ind[i,2]]
  par(mfg=c(ind[i,1],ind[i,2]))
  plot(PART_Y ~ X,ylab="Residuals for species i",xlab="log(Biomass) of species j")
  abline(c(0,0))#OBS! use this if partial residuals -> lines(X,X)
  lines(loess.smooth(X,PART_Y),col="red")
  tex <- paste("B(",as.character(ind[i,])[1],",",as.character(ind[i,])[2],")",sep="")
  mtext(tex,3,adj=1,col="Black")
  if(i==1){
    mtext(expression(bold(a)),3,adj=0,col="Black")
  }
}

# check for unexplained non-linearities in exploitation rates
i_max=sum(param$D!=0)
ind <- which(param$D!=0,arr.ind=TRUE)
names <- c("Cod exploitation rate","Sprat exploitation rate","Herring exploitation rate")
for(i in c(1:i_max)){
  PART_Y <- param$Res[,ind[i,1]] 
  X <- param$F[2:(dim(param$X)[1]),ind[i,2]]
  plot(PART_Y ~ X,ylab="Residuals",xlab=names[i])
  abline(c(0,0)) 
  lines(loess.smooth(X,PART_Y),col="red",lwd=1.5)
  if(i==1){
    mtext(expression(bold(b)),3,adj=0,col="Black")
  }
}
dev.off()
}

#---------------------------------------------------------------------#
# Fig S4 - A plot used to test the prediction accuracy of a MAR-model #
#---------------------------------------------------------------------#
# Requires function Boot_param

FigureS4 <- function(param){
  
  #------------------#
  # structurize data #
  #------------------#
  S <- dim(param$X)[2]
  t <- dim(param$X)[1]
  nb_cov <- dim(param$U)[2]
  train_int <- 1:17
  test_int <- 18:27
  
  X_train <- param$X[train_int,] # use first years of data and predict last years of data 
  X_train_mean <- colMeans(X_train)
  X_train <- X_train-matrix(X_train_mean,length(train_int),S,byrow=TRUE) # center data
  
  X_test <- param$X[test_int,]-matrix(X_train_mean,length(test_int),S,byrow=TRUE) # center data based on training period
  X_test_mu <- colMeans(X_test)
  
  
  # Standardize environmental data based on training data
  if(all(param$U==0)){
    U_train <- param$U[train_int,]
    U_test <- param$U[test_int,]
    U_test_mu <- colMeans(param$U)
  }else{
    U_train <- scale(param$U[train_int,])
    U_train_mean <- attributes(U_train)$"scaled:center"
    U_train_sd <- attributes(U_train)$"scaled:scale"
    U_train <- U_train[,]
    U_test <- (param$U[test_int,]-matrix(U_train_mean,length(test_int),S,
                                         byrow=TRUE))/matrix(U_train_sd,length(test_int),S,byrow=TRUE)
    U_test_mu <- colMeans(U_test)
  }
  
  # Standardize exploitation rate data based on training data
  F_train <- scale(param$F[train_int,])
  F_train_mean <- attributes(F_train)$"scaled:center"
  F_train_sd <- attributes(F_train)$"scaled:scale"
  F_train <- F_train[,]
  F_test <- (param$F[test_int,]-matrix(F_train_mean,length(test_int),S,
                                       byrow=TRUE))/matrix(F_train_sd,length(test_int),S,byrow=TRUE)
  F_test_mu <- colMeans(F_test)
  
  DAT_train <- list(X_train,F_train,U_train)
  names(DAT_train) <- c("X","F","U")
  
  # fit model
  capture.output(fit <- VARX(DAT_train$X,1,cbind(DAT_train$F,DAT_train$U),0,fixed=param$struct,output=F,
              include.mean=FALSE)) 
  
  param_train <- list(matrix(0,S,1),fit$Phi,fit$beta[,(S+1):(S+nb_cov)],fit$beta[,1:S],fit$Sigma,
                      fit$residuals,DAT_train$X,DAT_train$U,DAT_train$F,param$struct)
  names(param_train) <- c("A","B","C","D","R","Res","X","U","F","struct")
  
  
  #-----------------------------------------------------------#
  # Create boot strapped confidence intervals for predictions #
  #-----------------------------------------------------------#
  
  # mean predictions for the last part of the time series, given mean fishing and environmental data
  mu_test <- solve(diag(S)-param_train$B)%*%(param_train$C%*%
                                               U_test_mu+param_train$D%*%F_test_mu) 
  
  # Create confidence intervals for mean predictions
  n_boot <- 500
  Boot_test <- Boot_param(param_train,n_boot) # Create bootstrapped parameter sets
  mu_test_boot <- matrix(0,S,n_boot)
  for(i in 1:(n_boot)){
    mu_test_boot[,i] <- solve(diag(S)-Boot_test[[i]]$B)%*%
      (Boot_test[[i]]$C%*%U_test_mu+Boot_test[[i]]$D%*%F_test_mu)
  }
  mu_test_CI.low <- apply(mu_test_boot,1,quantile,0.025)
  mu_test_CI.high <- apply(mu_test_boot,1,quantile,0.975)
  
  # Predict timeseries
  mean_rev <- matrix(X_train_mean,S,t,byrow=FALSE) 
  param_train$U <- as.matrix(rbind(param_train$U,U_test))
  param_train$F <- as.matrix(rbind(param_train$F,F_test))
  Y_pred <- matrix(0,S,t)
  Y_pred[,max(train_int)] <- t(param_train$X[max(train_int),]) # take initial value as starting point
  for(i in test_int){
    Y_pred[,i] <- param_train$A+param_train$B%*%Y_pred[,i-1]+
      param_train$C%*%param_train$U[i,]+param_train$D%*%param_train$F[i,]
  }
  
  # Create confidence intervals for predicted time series
  Y_temp <- matrix(0,S,t)
  Y_temp[,max(train_int)] <- t(param_train$X[max(train_int),])
  Y_rand <- c()
  repl <- 2000
  Res <- param_train$Res
  
  # Simulate predictions
  for(j in 1:repl){
    Res_boot <- rmnorm(n = t, mean = rep(0, S), param_train$R, sqrt=NULL) 
    for(i in test_int){
      Y_temp[,i] <- param_train$A+param_train$B%*%Y_temp[,i-1]+
        param_train$C%*%param_train$U[i,]+param_train$D%*%param_train$F[i,]+Res_boot[i-1,]
    }
    Y_rand <- cbind(Y_temp,Y_rand)
  }
  
  # Extract quantiles
  quant <- c()
  for(i in 1:(dim(Y_temp)[1]*dim(Y_temp)[2])){
    index <- seq.int(i,dim(Y_rand)[1]*dim(Y_rand)[2],dim(Y_temp)[1]*dim(Y_temp)[2])
    quant[i] <- quantile(Y_rand[index],0.025)
  }
  quant_low <- matrix(quant,dim(Y_pred)[1],dim(Y_pred)[2])
  
  quant <- c()
  for(i in 1:(dim(Y_temp)[1]*dim(Y_temp)[2])){
    index <- seq.int(i,dim(Y_rand)[1]*dim(Y_rand)[2],dim(Y_temp)[1]*dim(Y_temp)[2])
    quant[i] <- quantile(Y_rand[index],0.975)
  }
  quant_high <- matrix(quant,dim(Y_pred)[1],dim(Y_pred)[2])
  
  #-------------#
  # Plot figure #
  #-------------#
  path <- "Output/S4.png"
  png(file=path,width=4.5,height=6,units="in",res=300)
  par(mar=c(2,4,1,1))
  par(mfcol=c(4,1))
  
  #-----------------------#
  # Plot mean predictions #
  #-----------------------#
  
  mu_test_CI <- rbind(mu_test_CI.high,mu_test_CI.low)
  p=0.05
  r=0.15
  x_value <- c(1:3)
  w <- 0.1
  
  # predictions
  plot((mu_test+mean_rev[,1]+param$mean_ln)~x_value,xlim=c(0,4),ylim=c(-25,25)
       , ylab=expression('log(Biomass'[mean2005-2014]*')'),
       type="p",pch=4,cex=2,xaxt="n")
  axis(1, at=1:3, labels=c("Cod","Sprat","Herring"))
  
  # confidence intervals
  lines(rep(x_value[1],2),mean_rev[1]+mu_test_CI[,1]+param$mean_ln[1]) 
  lines(c(x_value[1]+w,x_value[1]-w),mean_rev[1]+param$mean_ln[1]+rep(mu_test_CI[1,1],2)) 
  lines(c(x_value[1]+w,x_value[1]-w),mean_rev[1]+param$mean_ln[1]+rep(mu_test_CI[2,1],2)) 
  
  lines(rep(x_value[2],2),mean_rev[2]+mu_test_CI[,2]+param$mean_ln[2]) 
  lines(c(x_value[2]+w,x_value[2]-w),mean_rev[2]+param$mean_ln[2]+rep(mu_test_CI[1,2],2)) 
  lines(c(x_value[2]+w,x_value[2]-w),mean_rev[2]+param$mean_ln[2]+rep(mu_test_CI[2,2],2)) 
  
  lines(rep(x_value[3],2),mean_rev[3]+param$mean_ln[3]+mu_test_CI[,3]) 
  lines(c(x_value[3]+w,x_value[3]-w),mean_rev[3]+param$mean_ln[3]+rep(mu_test_CI[1,3],2)) 
  lines(c(x_value[3]+w,x_value[3]-w),mean_rev[3]+param$mean_ln[3]+rep(mu_test_CI[2,3],2)) 
  
  # Observations
  points((X_test_mu+mean_rev[,1]+param$mean_ln)~x_value,cex=2)
  
  x_pos=par('usr')[1]+p*(par('usr')[2]-par('usr')[1])
  y_pos=par('usr')[3]+(1-r)*(par('usr')[4]-par('usr')[3])
  text(x_pos,y_pos,expression(bold(a)),adj=0.5,cex=1.25)
  
  #-------------------------------#
  # Plot true forward predictions #
  #-------------------------------#
  Years <- c(1988:2014) # years
  
  # Predictions cod
  plot((Y_pred[1,max(train_int):max(test_int)]+mean_rev[1]+param$mean_ln[1])~
         Years[max(train_int):max(test_int)],type="l",xlim=range(Years),
       ylim=c(3,6.5),xlab="Year",ylab="log(Cod biomass)",lwd=2)
  points((mean_rev[1]+quant_high[1,max(train_int):max(test_int)]+param$mean_ln[1])~
           Years[max(train_int):max(test_int)],type="l",lty=2)
  points((mean_rev[1]+quant_low[1,max(train_int):max(test_int)]+param$mean_ln[1])~
           Years[max(train_int):max(test_int)],type="l",lty=2)
  
  # Observations cod
  points((param$X[,1]+param$mean_ln[1])~Years,type="p")
  lines((param$X[,1]+param$mean_ln[1])~Years,col="gray")
  x_pos=par('usr')[1]+p*(par('usr')[2]-par('usr')[1])
  y_pos=par('usr')[3]+(1-r)*(par('usr')[4]-par('usr')[3])
  text(x_pos,y_pos,expression(bold(b)),adj=0.5,cex=1.25)
  
  # Predictions sprat
  plot((Y_pred[2,max(train_int):max(test_int)]+mean_rev[2]+param$mean_ln[2])~
         Years[max(train_int):max(test_int)],xlim=range(Years),type="l",ylim=c(4.5,8.5),
       xlab="Year",ylab="log(Sprat biomass)",lwd=2)
  points((mean_rev[2]+quant_high[2,max(train_int):max(test_int)]+param$mean_ln[2])~
           Years[max(train_int):max(test_int)],type="l",lty=2)
  points((mean_rev[2]+quant_low[2,max(train_int):max(test_int)]+param$mean_ln[2])~
           Years[max(train_int):max(test_int)],type="l",lty=2)
  
  # Observations sprat
  points((param$X[,2]+param$mean_ln[2])~Years,type="p")
  lines((param$X[,2]+param$mean_ln[2])~Years,col="gray")
  x_pos=par('usr')[1]+p*(par('usr')[2]-par('usr')[1])
  y_pos=par('usr')[3]+(1-r)*(par('usr')[4]-par('usr')[3])
  text(x_pos,y_pos,expression(bold(c)),adj=0.5,cex=1.25)
  
  # Predictions herring
  plot((Y_pred[3,max(train_int):max(test_int)]+mean_rev[3]+param$mean_ln[3])~
         Years[max(train_int):max(test_int)],xlim=range(Years),type="l",ylim=c(5.5,8.5),
       xlab="Year",ylab="log(Herring biomass)",lwd=2)
  points((mean_rev[3]+param$mean_ln[3]+quant_high[3,max(train_int):max(test_int)])~
           Years[max(train_int):max(test_int)],type="l",lty=2)
  points((mean_rev[3]+param$mean_ln[3]+quant_low[3,max(train_int):max(test_int)])~
           Years[max(train_int):max(test_int)],type="l",lty=2)
  
  # Observations herring
  points((param$X[,3]+param$mean_ln[3])~Years,type="p")
  lines((param$X[,3]+param$mean_ln[3])~Years,col="gray")
  x_pos=par('usr')[1]+p*(par('usr')[2]-par('usr')[1])
  y_pos=par('usr')[3]+(1-r)*(par('usr')[4]-par('usr')[3])
  text(x_pos,y_pos,expression(bold(d)),adj=0.5,cex=1.25)
  
  dev.off()
}

#-----------------------------------------------------------------------------------#
#                         Figs S9 & S10; Tabs S6 & S7                               #                                                 #
# - Sensitivity of the stationary distribution of MAR(1) models to the assumption - #
#           - of normally and temporarily uncorrelated process errors -             #
#-----------------------------------------------------------------------------------#

Figure_S9_S10_TAB_S6_S7 <- function(param) {
  
  rep <- 100000 # number of time steps for simulation of stationary distribution
  gamma1 <- 0.9 # skewness of skew-normal distribution 
  R <- param$R # process error covariance matrix
  R <- diag(diag(R)) # remove covariance
  B <- param$B 
  
  #--------------------------#
  # Simulate error processes #
  #--------------------------#
  
  rnd_sn <- c() # skew-normal
  rnd_n <- c() # IID normal
  rnd_ar.45 <- c() # ar(1)- process (alpha=0.45)
  rnd_ar.90 <- c() # ar(1)- process (alpha=0.90)
  
  for(i in 1:dim(R)[1]){
    
    # IID normal and skew-normal processes
    cp <- c(mean=0, sd=sqrt(R[i,i]), gamma1=gamma1)
    dp <- cp2dp(cp, "SN")
    rnd_sn <- rbind(rnd_sn,rsn(rep, dp=dp)) # skew-normal proc errors
    rnd_n <- rbind(rnd_n,rnorm(rep, mean=0,sd=sqrt(R[i,i]))) # normally distributed proc errors
    
    # ar-processes
    ar_values <- c(0.45,0.9) 
    rnd_ar.45 <- rbind(rnd_ar.45,arima.sim(model=list(ar=ar_values[1]),rep,
                                           sd=sqrt((R[i,i]*(1-(ar_values[1]^2)))))) 
    rnd_ar.90 <- rbind(rnd_ar.90,arima.sim(model=list(ar=ar_values[2]),rep,
                                           sd=sqrt((R[i,i]*(1-(ar_values[2]^2)))))) 
  }
  
  #---------------------#
  # simulate MAR-models #
  #---------------------#
  MAR_model <- function(E,B){
    X <- matrix(NA,dim(E)[1],dim(E)[2])
    X[,1] <- matrix(0,3,1)
    for(i in c(2:dim(E)[2])){
      X[,i]=B%*%X[,(i-1)]+E[,i]
    }
    return(X)
  }
  
  #-----------------------------------#
  # Simulate stationary distributions #
  #-----------------------------------#
  
  # Theoretical stationary distribution assuming normally IID distributed errors
  S <- dim(B)[1]
  V_temp <- solve(diag(S^2)-B%x%B)%*%as.matrix(as.vector(R)) # Calculate the Vec-form of the variance-covariance matrix
  V <- matrix(V_temp,S,S,byrow=FALSE)
  
  # simulate stationary distribution for skew-normal errors
  X_sn <- MAR_model(rnd_sn,B)
  X_n <- t(MASS::mvrnorm(rep,c(0,0,0),Sigma=V))
  X_ar.45 <- MAR_model(rnd_ar.45,B)
  X_ar.90 <- MAR_model(rnd_ar.90,B)
  
  #---------------------------------#
  # calculate distribution overlaps #
  #---------------------------------#
  dist_diff_sn <- matrix(NA,dim(X_n)[1],2)
  dist_diff_ar <- array(NA,c(3,2,dim(X_n)[1]),dimnames=list(c("X1-X2","X1-X3","X2-X3")
                                                            ,c("process error","Stationary distribution"),c("Cod","Sprat",
                                                                                                            "Herring")))
  for(i in c(1:dim(X_n)[1])){
    
    # distribution area difference skew-normal/normal  
    x <- list(X1=rnd_sn[i,],X2=rnd_n[i,])
    out <- overlap(x)
    dist_diff_sn[i,1] <- 1-out$OV
    x <- list(X1=X_sn[i,],X2=X_n[i,])
    out <- overlap(x)
    dist_diff_sn[i,2] <- 1-out$OV
    
    # distribution area differences for autocorrelated process errors
    x <- list(X1=rnd_n[i,],X2=rnd_ar.45[i,],X3=rnd_ar.90[i,])
    out <- overlap(x)
    dist_diff_ar[,1,i] <- 1-out$OV
    x <- list(X1=X_n[i,],X2=X_ar.45[i,],X3=X_ar.90[i,])
    out <- overlap(x)
    dist_diff_ar[,2,i] <- 1-out$OV
    
  }
  dist_diff_sn <- as.data.frame(dist_diff_sn)
  names(dist_diff_sn)=c("proc_error","stat_dist")
  
  #------------------------------------------#
  # arrange data in long format for plotting #
  #------------------------------------------#
  species <- rep(rep(c("Cod","Sprat","Herring"),each=rep),8)
  distribution <- rep(c("Process error","Stationary distribution"),each=length(species)/2)
  dist_type <- rep(c(rep("Skew normal",length(species)/8),
                     rep("Normal",length(species)/8),rep("ar.45",length(species)/8),
                     rep("ar.90",length(species)/8)),2)
  result <- c(c(t(rnd_sn)),c(t(rnd_n)),c(t(rnd_ar.45)),c(t(rnd_ar.90)),
              c(t(X_sn)),c(t(X_n)),c(t(X_ar.45)),c(t(X_ar.90)))
  dat <- data.frame(distribution=distribution,dist_type=dist_type,
                    species=species,result=result)
  
  #--------------#
  # Plot figures #
  #--------------#
  
  # Fig S9 
  myplot <- ggplot(dat, aes(x=result, fill=dist_type)) + geom_density(alpha=.3) + 
    facet_grid(vars(species),vars(distribution)) + labs(x="Value") +
    guides(fill=guide_legend(title="Process error\ndistribution"))
  myplot %+% subset(dat, dist_type %in% c("Skew normal", "Normal"))
  ggsave("S9.png",width=18,height=8.9,units="cm",path="Output") # save to file
  
  # Fig S10
  myplot %+% subset(dat, dist_type %in% c("Normal","ar.45","ar.90")) +
    guides(fill=guide_legend(title="Process error\nautocorrelation",label.hjust = 0)) + 
    scale_fill_discrete(name="Process error autocorrelation",breaks=c("Normal","ar.45","ar.90"),
                        labels=c(expression(rho==0), expression(rho==0.45),
                                 expression(rho==0.9)),position="left")
  ggsave("S10.png",width=18,height=8.9,units="cm",path="Output") # save to file
  
  #-------------#
  # Save tables #
  #-------------#
  
  write.csv2(dist_diff_sn,"Output/TAB_S6.csv")
  write.csv2(dist_diff_ar,"Output/TAB_S7.csv")
}


##########
#--------#
# TABLES #
#--------#
##########

#--------------------------------------------#
# Tab. S1 - Stationarity test                #
#--------------------------------------------#

TAB_S1 <- function(param){
  
  # stationarity tests for biomass variables  
  pp_X <- apply(param$X,2,function(x){a <- pp.test(x,output=FALSE); 
  return(a[1,2:3])})
  df_X <- apply(param$X,2,function(x){a <- adf.test(x,output=FALSE); 
  return(a$type1[1,2:3])})  
  
  # stationarity tests for exploitation rate
  pp_exp <- apply(param$F,2,function(x){a <- pp.test(x,output=FALSE); 
  return(a[1,2:3])})
  df_exp <- apply(param$F,2,function(x){a <- adf.test(x,output=FALSE); 
  return(a$type1[1,2:3])})  
  
  tab <- cbind(rbind(pp_X,df_X),rbind(pp_exp,df_exp))
  tab <- round(tab,digits=2)
  tab <- rbind(c(rep("Biomass",3),rep("Exploitation",3)),
               tab)
  tab <- cbind(c("Variable","Dickey-Fuller","Dickey-Fuller",
                 "Phillips-Perron","Phillips-Perron"),tab)
  tab <- data.frame(tab)
  
  # Save matrix
  write.csv2(tab,file="Output/TAB_S1.csv")
}  

#----------------------------#
# Tab. S2 - parameter values #
#----------------------------#

TAB_S2 <- function(Boot){

# A-vector
A <- list()
A$est <- round(param$A,digits=2)
A$conf <- round(quantile(as.numeric(unlist(Boot)[names(unlist(Boot))=="A1"]),c(0.025,0.975)),digits=2) 
A$conf <- rbind(A$conf,round(quantile(as.numeric(unlist(Boot)[names(unlist(Boot))=="A2"]),c(0.025,0.975)),digits=2)) 
A$conf <- rbind(A$conf,round(quantile(as.numeric(unlist(Boot)[names(unlist(Boot))=="A3"]),c(0.025,0.975)),digits=2)) 

B <- list()
B$est <- round(param$B,digits=2)
B$conf <- matrix(0,length(param$A),length(param$A))

for(i in c(1:length(c(B$conf)))){
  id <- paste("B",as.character(i),sep="")
  B$conf[i]<- paste(as.character(round(quantile(as.numeric(unlist(Boot)[names(unlist(Boot))==id]),c(0.025,0.975)),digits=2)),collapse = ";")
}

C <- list()
C$est <- round(param$C,digits=2)
C$conf <- matrix(0,dim(param$C)[1],dim(param$C)[2])

for(i in c(1:length(c(C$conf)))){
  id <- paste("C",as.character(i),sep="")
  C$conf[i]<- paste(as.character(round(quantile(as.numeric(unlist(Boot)[names(unlist(Boot))==id]),c(0.025,0.975)),digits=2)),collapse = ";")
}

D <- list()
D$est <- round(param$D,digits=2)
D$conf <- matrix(0,dim(param$D)[1],dim(param$D)[2])
for(i in c(1:length(c(D$conf)))){
  id <- paste("D",as.character(i),sep="")
  D$conf[i]<- paste(as.character(round(quantile(as.numeric(unlist(Boot)[names(unlist(Boot))==id]),c(0.025,0.975)),digits=2)),collapse = ";")
}

lambda <- list()
lambda$est <- round(max(Mod(eigen(param$B)$values)),digits=2)
lambda$conf <- paste(as.character(round(quantile(as.numeric(unlist(Boot)[names(unlist(Boot))=="lambda"]),c(0.025,0.975)),digits=2)),collapse = ";")                   

A <- paste(as.character(A$est),"[",as.character(A$conf[,1]),as.character(A$conf[,2]),"]",sep="")
B <- matrix(paste(as.character(B$est),"[",as.character(B$conf),"]",sep=""),dim(B$est)[1],dim(B$est)[2])
C <- matrix(paste(as.character(C$est),"[",as.character(C$conf),"]",sep=""),dim(C$est)[1],dim(C$est)[2])
D <- matrix(paste(as.character(D$est),"[",as.character(D$conf),"]",sep=""),dim(D$est)[1],dim(D$est)[2])
lambda <- paste(as.character(lambda$est),"[",lambda$conf,"]",sep="")


names(A) <- c("Cod","Sprat","Herring")
colnames(B) <- c("Cod","Sprat","Herring")
rownames(B) <- c("Cod","Sprat","Herring")
colnames(C) <- c("Env_cov1","Env_cov2")
rownames(C) <- c("Cod","Sprat","Herring")
colnames(D) <- c("D.Cod","D.Sprat","D.Herring")
rownames(D) <- c("Cod","Sprat","Herring")
names(lambda) <- "lambda"
aicc <- param$aicc
names(aicc) <- "aicc"

Est <- data.frame(B,C,D,aicc,lambda)

write.csv2(Est,file="Output/TAB_S2.csv")
}


#-----------------------------#
# TAB S3_S5 - Limits for ESER #
#-----------------------------#
#
# requires
# ESER - an R-script for estimating ESER limits
# Criteria - The Criterias to use when calculating ESER-limits
#
TAB_S3_S5 <- function(Boot,Criteria){
  
  # Some initial settings
  S <- length(Boot$param$A) # number of species
  all_ESER <- c() # ESER-limits for all boot strapped parameter sets
  GLS_est <- c() # ESER-limits for model
  n_boot <- length(Boot)-1 # number of boot strapper parameter sets
  limit <- c(-1.518207,-2.377131,-2.227167) # limits below wich exploitation rate on original scale leads to no exploitation 
  
  #-----------------------#
  # Calculate ESER-limits #
  #-----------------------#
  
  # Calculate ESER for boot-strapped parameter sets
  for(i in 1:(n_boot)){
    print(i)
    Fish <- c()
    for(j in 1:S){
      Criteria$spID <- j
      print(j)
      delta <- ESER(Boot[[i]],Criteria)
      Fish <- cbind(Fish,delta)
    }
    all_ESER <- rbind(all_ESER,Fish)
  }
  
  # value from most parsimonious model
  for(j in 1:S){
    Criteria$spID <- j
    print(j)
    delta <- ESER(Boot$param,Criteria)
    GLS_est <- cbind(GLS_est,delta)
  }
  
  #-----------------#
  # Extract results #
  #-----------------#

  # Find the number of non-stationary models
  non_stat <- apply(all_ESER,2,function(x) x=="MAR(1)-model is not stationary")
  non_stat <- colSums(non_stat,na.rm=TRUE) # find number of non-stationary cases
  
  # Find the number of cases with only one root
  P <- all_ESER[rownames(all_ESER)=="ESER.root",]
  root <- apply(P,2,function(x) as.numeric(x)!="NA")
  root_temp <- colSums(root,na.rm=TRUE) # number of cases with only one root(unidirectional effect of fishing)
  P <- all_ESER[rownames(all_ESER)=="ESER.univariate",]
  root <- apply(P,2,function(x) as.numeric(x)!="NA")
  root <- colSums(root,na.rm=TRUE) + root_temp # number of cases with only one root
  
  # number of cases when root can not be found due to high initial probability 
  # of going below blim
  P <- all_ESER[rownames(all_ESER)=="ESER.univariate",]
  imp.univ <- apply(P,2,function(x) x=="impossible")
  imp.univ <- colSums(imp.univ,na.rm=T)
  P <- all_ESER[rownames(all_ESER)=="ESER.low",]
  imp.highlow <- apply(P,2,function(x) x=="impossible")
  imp.highlow <- colSums(imp.highlow,na.rm=T)
  
  imp <- imp.univ+imp.highlow
  
  # number of cases with high/low limits
  P <- all_ESER[rownames(all_ESER)=="ESER.low",]
  highlow <- apply(P,2,function(x) as.numeric(x)!="NA")
  highlow <- colSums(highlow,na.rm=T)
  
  # Check that the correct number of cases is extracted
  all_cases <- non_stat +root+imp+highlow
  if(any(all_cases!=n_boot)){
    stop("The number of different outcomes are not correctly calculated!!")
  }
  
  # Extract all upper limits for ESER
  P <- all_ESER[rownames(all_ESER)== "ESER.univariate" | 
                   rownames(all_ESER)== "ESER.high"| rownames(all_ESER)== "ESER.root",]
  id <- apply(P,2,function(x) as.numeric(x)!="NA")
  id <- which(id==TRUE,arr.ind=TRUE)
  values <- P[id]
  CIlowerUpF <- c()
  CIupperUpF <- c()
  F_high_unfeasible <- c()
  for(i in c(1:S)){
    temp <- as.numeric(values[id[,2]==i])
    CIlowerUpF[i] <- quantile(temp,0.025)
    CIupperUpF[i] <- quantile(temp,0.975)
    F_high_unfeasible[i] <- sum(temp<limit[i])
  }
  
  # Extract all lower limits for ESER
  P <- all_ESER[rownames(all_ESER)=="ESER.low",]
  id <- apply(P,2,function(x) as.numeric(x)!="NA")
  id <- which(id==TRUE,arr.ind=TRUE)
  values <- P[id]
  CIlowerlowF <- c()
  CIupperlowF <- c()
  F_low_unfeasible <- c()
  for(i in c(1:S)){
    temp <- as.numeric(values[id[,2]==i])
    CIlowerlowF[i] <- quantile(temp,0.025)
    CIupperlowF[i] <- quantile(temp,0.975)
    F_low_unfeasible[i] <- sum(temp<limit[i])
  }
  
  # Extract most parsimonious ESER-limits
  GLSLowF <- c()
  GLSUpF <- c()
  for(i in c(1:S)){
    GLSLowF[i] <- GLS_est[1,i]
    GLSUpF[i] <- GLS_est[2:4,i][!is.na(GLS_est[2:4,i])]
  }
  
  #-----------------------------#
  # Combine results to matrices #
  #-----------------------------#
  
  # Put together data on ESER-limits
  ESER_limits <- data.frame(GLSLowF,GLSUpF,CIlowerUpF, CIupperUpF,
                            CIlowerlowF,CIupperlowF)
  ESER_limits <- t(ESER_limits)
  colnames(ESER_limits) <- c("Cod","Sprat","Herring")
  
  # Put together a matrix with all possible outcomes
  tab <- rbind(non_stat,root,imp,highlow,F_low_unfeasible,F_high_unfeasible)
  colnames(tab) <- c("Cod","Sprat","Herring")

  # Save tables
  path <- "Output/TAB_S3.csv"
  write.table(ESER_limits,path,append=TRUE,col.names=FALSE)
  path <- "Output/TAB_S5.csv"
  write.table(tab,path)
}


#--------------------------------------------#
# Tab. S4 - Sensitivity to exploitation rate #
#--------------------------------------------#

TAB_S4 <- function(Boot){

# Initial settings  
M <- list()
M$est <- round(solve(diag(dim(param$B)[1])-param$B)%*%param$D,digits=2)
M$conf <- matrix(0,dim(M$est)[1],dim(M$est)[2])

# Extract data from boot strapped parameter sets
for(i in c(1:length(c(M$conf)))){
  id <- paste("M",as.character(i),sep="")
  M$conf[i]<- paste(as.character(round(quantile(as.numeric(unlist(Boot)
                  [names(unlist(Boot))==id]),c(0.025,0.975)),digits=2)),
                  collapse = ";")
}

# Create final matrix
M <- matrix(paste(as.character(M$est),"[",as.character(M$conf),"]",sep=""),
            dim(M$est)[1],dim(M$est)[2])
colnames(M) <- c("Sens.F.Cod","Sens.F.Sprat","Sens.F.Herring")
rownames(M) <- c("Cod","Sprat","Herring")
Est <- data.frame(M)

# Save matrix
write.csv2(Est,file="Output/TAB_S4.csv")
}


