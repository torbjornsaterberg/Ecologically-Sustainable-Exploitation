#----------------------------------------------------------------------------#
#                             -Estimate ESER-                                #
# A script that estimates Ecologically Sustainable Exploitation Rates (ESER) #
#                    from multi-species time series data                     #
#----------------------------------------------------------------------------#
#
# This script estimates ESERs, i.e. exploitation rates associated with a low risk 
# that any species goes below its predefined critical biomass limit, using
# multivariate autoregressive models (Ives et al. 2003). This is done using the 
# stationary distribution of MAR(1)-process with covariates:
#
# MAR(1)-model with covariates
# X(t)=A+BX(t-1)+CU(t)+DF(t)+E(t)
# E(t)~MVN(0,R)
#
# Stationary distribution
# X_inf_mean=inv(I-B)*(A+CU_mean+D(F_mean+eps*E))
# X_inf_VAR=inv(I-B(Kron)B)Vec(C*Cov(U)*C+R))
# 
# INPUT: param - A list containing fitted MAR parameters: 
#                    A - A column vector with per capita growth rates of species
#                    B - Per log-abundance interactions effect of species j on 
#                        species i's per capita growth rate.
#                    C - The per unit covariate(U) effects on species' per capita 
#                        growth rates. 
#                    D - The per unit fishing mortality(F) effect on species' per 
#                        capita growth rates.
#                    R - The variance-covariance matrix of the multivariate
#                        normally distributed process error with mean vector 0
#                    U_mean - A vector with mean of environmental variables                              
#                    U_cov - The variance-covariance matrix of environmental variables
#                    F_mean - A vector with mean of exploitation rates                            
#        
#        Criteria - A list containing estimation details:
#                    threshold - A vector of critical biomass limits for all species.
#                    risk - The risk that any species within a community goes below 
#                           its population target level.
#                    spID - The ID of the concerned species.
#        
#
# OUTPUT:   ESER - a vector with three potential ESER-limit outcomes
#                   low - the lower exploitation rate limit when 2 limits are possible 
#                   high - the upper exploitation rate limit when 2 limits are possible
#                   univariate - The limit when one species is not affecting the other species
#                   root - the only possible limit if effects of exploitation within the community
#                          are unidirectional.   
###################

# Main function
ESER <- function(param,Criteria){

# Check if MAR(1)-model is stationary 
if(any(Mod(eigen(param$B)$values)>1)){
return('MAR(1)-model is not stationary')
}

# Check that the probability of going below threshold is not already met before changing F_mean
if((ESTP(0,Criteria,param)-Criteria$risk)>0){
  cat('Warning!!! Probability of going below threshold is larger than the given risk')
}

# Calculate the covariance matrix of the stationary distribution 
S <- length(param$A)
V_temp <- solve(diag(S^2)-param$B%x%param$B)%*%as.matrix(as.vector(param$R+param$C%*%param$U_cov%*%t(param$C))) # Calculate the Vec-form(add this if we want cov to affect stat dist. :) of the variance-covariance matrix
V <- matrix(V_temp,S,S,byrow=FALSE)

# Compute intial guess for finding roots of objective function
mu_thresh <- Criteria$threshold-qnorm(Criteria$risk+0.05,0,sd=sqrt(diag(V))) # mean of marginal dist. for species spID when at target level
mu <- solve(diag(S)-param$B)%*%(param$A+param$C%*%param$U_mean+param$D%*%
                                  (param$F_mean)) 
delta_change <- mu_thresh-mu
delta_change_mat <- matrix(rep(delta_change,S),S,S)
sens <- solve(diag(S)-param$B)%*%param$D # sensitivity of mean to a change in exploitation rate.
F_delta <- delta_change_mat/sens
F_delta[is.infinite(F_delta)] <- NA
guess_min <- apply(F_delta,2,min,na.rm=T) 
guess_max <- apply(F_delta,2,max,na.rm=T)
init_guess <- c(guess_min[Criteria$spID],guess_max[Criteria$spID])

# Find roots
#
# three potential cases: 
# (1) Only one root due to no direct effect of species spID on other species.
# That is, focal species is not affecting other species in the model.
# (2) Only one root because exploitation exlusively has negative or positive effects on
#     focal species and other dependent species.
# (3) Two roots because of negative and positive indirect effects of exploitation 
#     on different species.  

if(init_guess[1]==init_guess[2]){
  
  # check if it is possible to reach objective when target species 
  # is not included in risk calculation.
  marg_dens <- Cum_dens(mu[-Criteria$spID],V[-Criteria$spID,-Criteria$spID],
                     Criteria$threshold[-Criteria$spID])
  if(marg_dens>Criteria$risk){
  cat('Warning!!! The probability of going below thresholds can impossibly 
      be lower than the predefined risk for the investigated case')
  ESER.univariate <- "impossible"
  ESER.low <- NA
  ESER.high <- NA
  ESER.root <- NA
  }else{
    
  # initial guess value  
  init_guess <- init_guess[1]+c(-3,3)
  
  # find root
  ESER.univariate <- uniroot(f,init_guess,Criteria,param,tol=1e-10)
  ESER.univariate <- ESER.univariate$root 
  ESER.low <- NA
  ESER.high <- NA
  ESER.root <- NA
  
  ###### use this code to plot objective function ######
  #   X <- seq(init_guess[1],init_guess[2],length.out=100)
  #   Y <- apply(t(X),2,f,Criteria,param)
  #   plot(Y~X) # use this if you want to plot objective function
  #######################################################
  }
  }
else if(init_guess[1]!=init_guess[2] && sign(init_guess[1])==sign(init_guess[2])) {
  
  # initial guess values
  init_guess <- init_guess[1]+abs(init_guess[1])*c(-20,20)
  print(init_guess)
  
  # find root
  ESER.root <- uniroot(f,init_guess,Criteria,param,tol=1e-10)
  ESER.root <- ESER.root$root
  ESER.low <- NA
  ESER.high <- NA
  ESER.univariate <- NA
  
  ###### use this code to plot objective function ######
  #   X <- seq(init_guess[1],init_guess[2],length.out=100)
  #   Y <- apply(t(X),2,f,Criteria,param)
  #   plot(Y~X) # use this if you want to plot objective function
  #######################################################
}
else{
  
# intial guess for rootfinding of ESER-limits
#ev_obj <- apply(t(F_delta[,Criteria$spID]),2,f,Criteria,param)
#ind_pos <- which(ev_obj>=0)
#ind <- match(sort(ev_obj[ind_pos]),ev_obj)[1:2]
#init_guess <- sort(F_delta[ind,Criteria$spID])

  
###### use this code to plot objective function ######
#  X <- seq(init_guess[1],init_guess[2],length.out=100)
#  Y <- apply(t(X),2,f,Criteria,param)
#   plot(Y~X) # use this if you want to plot objective function
#######################################################

# check if it is possible to find zero roots(if optimize yields positive values it is not)
# find minimum of objective function
init_val <- t(t(seq(init_guess[1],init_guess[2],length.out=100)))
invisible(capture.output(dat <- multistart(init_val, f, gr=NULL, lower=-Inf, upper=Inf, 
           method=NULL,hessian=FALSE, control=list(trace=0,silence=TRUE), Criteria, param)))
obj_value <- min(dat$value)
obj_param <- dat$p1[which.min(dat$value)]
   
if(obj_value>0){
  ESER.low <- "impossible"
  ESER.high <- "impossible"
  ESER.univariate <- NA
  ESER.root <- NA
}else{
ESER.low <- uniroot(f,c(init_guess[1],obj_param),Criteria,param,tol=1e-10,extendInt="downX")
ESER.low <- ESER.low$root
ESER.high <- uniroot(f,c(obj_param,init_guess[2]),Criteria,param,tol=1e-10,extendInt="upX")
ESER.high <- ESER.high$root
ESER.univariate <- NA
ESER.root <- NA
}
}
ESER <- c(ESER.low,ESER.high,ESER.univariate,ESER.root)
names(ESER) <- c("ESER.low","ESER.high","ESER.univariate","ESER.root")
return(ESER)  
} # end of main function

#####################
# Objective function(find root of this function)
#
f <- function(eps,Criteria,param){
  (ESTP(eps,Criteria,param)-Criteria$risk)
} 

################################################################################################
# Estimate the probability that any species goes below its critical biomass level
#
ESTP <- function(eps,Criteria,param){

  # Intialize parameters
  P <- 0 # probability of going below critical Biomass limit
  A <- param$A 
  B <- param$B 
  R <- param$R 
  C <- param$C 
  U_cov <- param$U_cov 
  U_mean <- param$U_mean
  F_mean <- param$F_mean
  D <- param$D
  S <- length(param$A) # Number of species in the community
  E <- matrix(0,S,1) # Initialize extra mortality vector.
  E[Criteria$spID] <- 1 # For which species do we want to change the exploitation rate?

  
# Calculate mean and Variance-covariance of the multivariate normal stationary distribution  
mu <- solve(diag(S)-B)%*%(A+C%*%U_mean+D%*%(F_mean+eps*E)) # Calculate the mean value of the stationary distribution with new fishing mortality eps.
V_temp <- solve(diag(S^2)-B%x%B)%*%as.matrix(as.vector(R+C%*%U_cov%*%t(C))) # Calculate the Vec-form(add this if env cov affects stat dist: +) of the variance-covariance matrix
V <- matrix(V_temp,S,S,byrow=FALSE) # Re-order to a Variance-covariance matrix

# Use cumulative density function to calculate probability of going below target population levels.
for(i in 1:S){
  rand_perm <- combn(c(1:S),i) # Find all possible i-species subsets of a community with S species.  
  CDF_temp <- apply(rand_perm,2,EstMarProb,mu,V,Criteria$threshold) # Calculate P for each i-species subset.
  P <- P+((-1)^(i-1))*sum(CDF_temp) # Use the inclusion-exclusion principle to calculate P.
  }
 
return(P)
} # End of probability function ESTP

#######################################
# Marginal cumulative density functions
EstMarProb <- function(x,mu,V,threshold){ 
  P_limit <- pmnorm(threshold[x],mean=mu[x],varcov=V[x,x],
                  abseps=1e-16,maxpts=100000) # prob. that any of all species in a subset goes below Blim
  return(as.numeric(P_limit))
} # End of marginal cumulative density function.

####################################################################
# Calculate cumulative density from multivariate normal distribution
Cum_dens <- function(mu,V,threshold){
  P <- 0
  S <- length(mu)
# Use cumulative density function to calculate probability of going below target population levels.
for(i in 1:S){
 rand_perm <- combn(c(1:S),i) # Find all possible i-species subsets of a community with S species.
 CDF_temp <- apply(rand_perm,2,EstMarProb,mu,V,threshold) # Calculate P for each i-species subset.
 P <- P+((-1)^(i-1))*sum(CDF_temp) # Use the inclusion-exclusion principle to calculate P.
}

 return(P)
} # End of cumulative density function.