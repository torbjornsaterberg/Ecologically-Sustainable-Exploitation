###################################################################
# Boot_param - A script which gives bootstrapped parameter sets for
#              MAR(1)-models with exogenous variables
#
# Input: param - A list containing fitted MAR(1)-parameters
#
#     A - A column vector with per capita growth rates of species
#     B - Per log-abundance interactions effect of species j on 
#         species i's per capita growth rate
#     C - The per unit covariate(U) effects on species' per capita
#         growth rates 
#     D - The per unit exploitation rate (F) effect on species' per
#         capita growth rates
#     R - The variance-covariance matrix of the multivariate
#         normally distributed process error with mean vector 0
#     Res - A matrix with model residuals 
#     struct - A design matrix for fitting MAR models with exogenous variables
#
#        n_boot - The number of boot strap parameter sets to produce
#
# Output: Boot_param - A list with each sublist containing one parameter setting
#

Boot_param <- function(param,n_boot){
  

# Initial parameters  
param_boot_all <- list()
Res <- param$Res
Res <- Res-matrix(colMeans(Res),dim(Res)[1],dim(Res)[2],
                  byrow=TRUE) # center residuals prior bootstrapping, See Lütkepohl 2005
S <- dim(param$B)[1] 
t <- dim(param$X)[1] # Length of time series

# Chose initial value for bootstrapping
X0 <- solve(diag(S)-param$B)%*%param$A+param$C%*%param$U[1,] + 
  param$D%*%param$F[1,] # mean value + effect of covariates(preferred approach for relively unstable systems (See Ives et al. 2003)

# Creat matrix with permutations
Q<-c() 
for(i in 1:n_boot){ Q <- rbind(Q,sample(c(1:dim(Res)[1]),dim(Res)[1],replace=TRUE))} #Create some random permutations


#---------------------------------#
# Create Bootstrap parameter sets # 
#---------------------------------#
for(j in 1:n_boot){

# initialize parameters  
Res_boot <- Res[Q[j,],] # resample residuals 
Y <- matrix(0,S,t) # initial 
Y[,1]=X0

# simulate model
for(i in c(1:(t-1))){
    Y[,i+1] <- as.matrix(param$A)+param$B%*%Y[,i]+param$C%*%as.matrix(param$U[i+1,])+param$D%*%as.matrix(param$F[i+1,])+as.matrix(Res_boot[i,])
}

# Fit model using GLS
capture.output(fit <- VARX(t(Y),1,cbind(param$F,param$U),0,fixed=param$struct,output=F,
                           include.mean=FALSE))  

# check if model was fitted assuming no constant vector
if(is.null(fit$Ph0)){
  fit$Ph0 <- matrix(0,S,1)
}

# save parameter sets
M <- solve(diag(S)-fit$Phi)%*%fit$beta[,1:S] # Long-term dynamic multiplier (or long-term indirect effects of fishing)
lambda <- max(Mod(eigen(fit$Phi)$values))
param_boot <- list(fit$Ph0,fit$Phi,fit$beta[,(S+1):ncol(fit$beta)],fit$beta[,1:S],fit$Sigma,param$U_mean,param$F_mean,param$U_cov,M,lambda)
names(param_boot) <- c("A","B","C","D","R","U_mean","F_mean","U_cov","M","lambda")

param_boot_all[[j]] <- param_boot
}
param_boot_all$param <- param
  return(param_boot_all)
}